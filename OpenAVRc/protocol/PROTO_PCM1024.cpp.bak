 /*
 **************************************************************************
 *                                                                        *
 *                 ____                ___ _   _____                      *
 *                / __ \___  ___ ___  / _ | | / / _ \____                 *
 *               / /_/ / _ \/ -_) _ \/ __ | |/ / , _/ __/                 *
 *               \____/ .__/\__/_//_/_/ |_|___/_/|_|\__/                  *
 *                   /_/                                                  *
 *                                                                        *
 *              This file is part of the OpenAVRc project.                *
 *                                                                        *
 *                         Based on code(s) named :                       *
 *             OpenTx - https://github.com/opentx/opentx                  *
 *             Deviation - https://www.deviationtx.com/                   *
 *                                                                        *
 *                Only AVR code here for visibility ;-)                   *
 *                                                                        *
 *   OpenAVRc is free software: you can redistribute it and/or modify     *
 *   it under the terms of the GNU General Public License as published by *
 *   the Free Software Foundation, either version 2 of the License, or    *
 *   (at your option) any later version.                                  *
 *                                                                        *
 *   OpenAVRc is distributed in the hope that it will be useful,          *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of       *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        *
 *   GNU General Public License for more details.                         *
 *                                                                        *
 *       License GPLv2: http://www.gnu.org/licenses/gpl-2.0.html          *
 *                                                                        *
 **************************************************************************
*/


#include "../OpenAVRc.h"

#define PULSES_SYNCHRO_TIME_US (500) // 500usec

/* http://serge.laforest.free.fr/pcm/PCM.htm#ancre04 */
enum pcmtype{
JRPCM,//Graupner/JR PCM
JRSPCM20,//Graupner/JR SPCM20
FUTPCM1024,//Robbe/Futaba PCM 1024
SIMPCM,//Simprpop PCM
};

const RfOptionSettingsvar_t RfOpt_PCM_Ser[] PROGMEM = {
  /*rfProtoNeed*/BOOL1USED,
  /*rfSubTypeMax*/6,
  /*rfOptionValue1Min*/-20,
  /*rfOptionValue1Max*/35,
  /*rfOptionValue2Min*/-4,
  /*rfOptionValue2Max*/10,
  /*rfOptionValue3Max*/0,
};

/*
void sendOptionsSettingsPcm()
{
  SetRfOptionSettings(pgm_get_far_address(RfOpt_PCM_Ser), // Used by PPM
                      STR_DUMMY,
                      STR_DUMMY,
                      STR_DUMMY,
                      STR_DUMMY,
                      STR_DUMMY,
                      STR_DUMMY,
                      STR_DUMMY);
  if (s_current_protocol==FUTPCM1024) g_model.PPMNCH = limit<uint8_t>(0,g_model.PPMNCH,2);
  g_model.PPMFRAMELENGTH = (g_model.PPMNCH-2) * 8;
  systemBolls.protoMode = NORMAL_MODE;
}
*/

void setupPulsesPCM(enum pcmtype proto);

void setupPulsesPCM(enum pcmtype proto)
{
  // Total frame length is a fixed 22.5msec (more than 9 channels is non-standard and requires this to be extended.)
  // Each channel's pulse is 0.7 to 1.7ms long, with a 0.3ms stop tail, making each complete cycle 1 to 2ms.

  // The pulse ISR is 2MHz that's why everything is multiplied by 2

  int16_t PCM_range = g_model.extendedLimits ? 640*2 : 512*2;   //range of 0.7..1.7msec

  //uint16_t q = (g_model.PPMDELAY*50+300)*2; // Channel sync pulse.
  uint16_t q = 2700; // Channel sync pulse = 2.7ms.

  int32_t rest = 28500u - q;

  // Futaba PCM1024 uses a fixed frame length of 28.5msec (14.25msx2).
  if(proto == FUTPCM1024) rest += (int32_t(g_model.PPMFRAMELENGTH))*1000;

  // PPM and PPM16 (Channels 1-8) use first half of array. PPMSIM and PPM16 (Channels 9-16) use last half.
  uint16_t *ptr = (proto == FUTPCM1024) ? &pulses2MHz.pword[0] : &pulses2MHz.pword[PULSES_WORD_SIZE/2];

  uint8_t p;
  // Fix PPM16 to 16 channels (8+8), No modification by GUI.
/*
  if(proto == FUTPCM1024 || proto == PPMSIM) p = 4 + (g_model.PPMNCH * 2); // Channels *2
  else if(proto == PPM16FIRST) p = 8;
  else p = 16; // PPM16 Channels 9-16.
*/

#if defined(X_ANY)
  //Xany_scheduleTx_AllInstance();
#endif

  for (uint8_t i=(proto == FUTPCM1024) ? 8 : 0; i<p; i++) { // Just do channels 1-8 unless PPM16 (9-16).
    int16_t v = limit((int16_t)-PCM_range, channelOutputs[i], (int16_t)PCM_range) + 2*PPM_CH_CENTER(i);
    rest -= v;
    *ptr++ = q;
    *ptr++ = v - q; // Total pulse width includes channel sync pulse.
  }

  *ptr++ = q;
  if (rest > 65535) rest = 65535; // Prevents overflows.
  if (rest < 9000)  rest = 9000;

  *ptr++ = rest - (PULSES_SYNCHRO_TIME_US *2);
  *ptr = 0; // End array with (uint16_t) 0;

  /* Précision des valeurs sur 10 bits
  Frame 1
  Synchro //2.7ms
  Canal 1 absolu
  Canal 3 absolu
  Canal 5 absolu
  Canal 7 absolu
  Canal 9 absolu
  Canal 2 diff
  Canal 4 diff
  Canal 6 diff
  Canal 8 diff
  Donnée de référence ?
  CRC 16 bit

  Frame 2
  Synchro //2.7ms
  Canal 1 diff
  Canal 3 diff
  Canal 5 diff
  Canal 7 diff
  Canal 9 diff
  Canal 2 absolu
  Canal 4 absolu
  Canal 6 absolu
  Canal 8 absolu
  Donnée de référence ?
  CRC 16 bit
  */
}

/*
 * PROTO_PCM1024 uses PB6 OC1B
 * 16 Bit Timer running @ 16MHz has a resolution of 0.5us.
 * This should give a PPM resolution of 2048.
*/
static uint16_t PROTO_PCM1024_cb2()
{
  if(*RptrB == 0) { // End of timing events.
    RptrB = &pulses2MHz.pword[0];
    // Set the PPM idle level.
    if (g_model.PULSEPOL) {
      TCCR1A = (TCCR1A | (1<<COM1B1)) & ~(1<<COM1B0); // Clear
    }
    else {
      TCCR1A |= (0b11<<COM1B0); // Set
    }
    TCCR1C = 1<<FOC1B; // Strobe FOC1.
    TCCR1A = (TCCR1A | (1<<COM1B0)) & ~(1<<COM1B1); // Toggle OC1x on next match.

    // Schedule next Mixer calculations.
    SCHEDULE_MIXER_END_IN_US(43540 + ((g_model.PPMFRAMELENGTH * 1000) / 2));
    setupPulsesPCM(FUTPCM1024);
    heartbeat |= HEART_TIMER_PULSES;
    dt = TCNT1 - OCR1B; // Show how long to setup pulses and ISR jitter.
    return PULSES_SYNCHRO_TIME_US *2;
  }
  else if (*(RptrB +1) == 0) { // Look ahead one timing event.
    // Need to prevent next toggle.
    // Read pin and store before disconnecting switching output.
    if(PINB & PIN6_bm) PORTB |= PIN6_bm;
    else PORTB &= ~PIN6_bm;
    TCCR1A &= ~(0b11<<COM1B0);
    return *RptrB++;
  }
  else // Toggle pin.
    return *RptrB++;
}


void PROTO_PCM1024_cb1()
{
uint16_t half_us = PROTO_PCM1024_cb2();

  if(! half_us) {
    PROTO_PCM1024_Cmds(PROTOCMD_RESET);
    return;
  }

//  dt = TCNT1 - OCR1B; // Calculate latency and jitter.
  if(dt > g_tmr1Latency_max) g_tmr1Latency_max = dt;
  if(dt < g_tmr1Latency_min) g_tmr1Latency_min = dt;

  OCR1B += half_us;
}


static void PROTO_PCM1024_reset()
{
  // Make pin idle state before disconnecting switching output.
  if(g_model.PULSEPOL) PORTB &= ~PIN6_bm;
  else PORTB |= PIN6_bm;
  TCCR1A &= ~(0b11<<COM1B0);
  TIMSK1 &= ~(1<<OCIE1B); // Disable Output Compare B interrupt.
  TIFR1 |= 1<<OCF1B; // Reset Flag.
}

static void PROTO_PCM1024_initialize()
{
#if defined(FRSKY)
  //telemetryPPMInit();
#endif

  RptrB = &pulses2MHz.pword[0];
  *RptrB = 0;

  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    ocr1b_function_ptr = PROTO_PCM1024_cb1; // Setup function pointer used in ISR.
    OCR1B = TCNT1 + (16000U *2);
    TIFR1 |= 1<<OCF1B; // Reset Flag.
    TIMSK1 |= 1<<OCIE1B; // Enable Output Compare interrupt.
  }
}


const void * PROTO_PCM1024_Cmds(enum ProtoCmds cmd)
{
  switch(cmd) {
    case PROTOCMD_INIT:
      PROTO_PCM1024_initialize();
    return 0;
    case PROTOCMD_RESET:
      PROTO_PCM1024_reset();
    return 0;
  case PROTOCMD_GETOPTIONS:
    SetRfOptionSettings(pgm_get_far_address(RfOpt_PCM_Ser), // Used by PPM
                        STR_DUMMY,
                        STR_DUMMY,
                        STR_DUMMY,
                        STR_DUMMY,
                        STR_DUMMY,
                        STR_DUMMY,
                        STR_DUMMY
                        );
     return 0;
        default: break;
  }
  return 0;
}

